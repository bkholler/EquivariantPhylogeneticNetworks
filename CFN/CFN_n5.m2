load "CFN_Networks.m2"


-- set number of leaves and model
n = 5
N = digraph(toList(1..10), {{6, 1}, {7, 2}, {8, 3}, {9, 4}, {10, 5}, {8, 7}, {8, 9}, {7, 6}, {9, 10}, {10, 6}});
M = CFNmodel


-- setup the ring and compute the vanishing ideal of the CFN model on the standard 4-sunlet
-- by results of https://arxiv.org/pdf/2312.07450, the ideal is generated by quadratics 
-- so it suffices to compute all quadratic generators of the kernel of the corresponding ring map
S = qRing(n, M);
images = sunletParam(n, M);
R = ring images_0;
phi = map(R, S, images);
H = componentsOfKernel(2, phi);
I = ideal delete(null, flatten values H);


-- compute the n!/2 = 60 permutations which correspond to distinct 5-sunlets
perms = permutations(5);
permsModLeafSwitch := while #perms > 0 list(

		sigma := perms_0;
        perms = delete(sigma_{0,4,3,2,1}, perms);
		perms = delete(sigma, perms);
		sigma
);


-- make a hash table where the keys are the five sunlets and the values are their ideal, created by permuting the indices of the original ideal
fiveSunletIdeals = hashTable for sigma in permsModLeafSwitch list(

    tau := (sigma / (i -> i + 1)) // permutation // inverse // toList / (i -> i -1);
    permuteVars :=  apply(gens S, j -> j => q_(toSequence (last baseName j)_tau));
    J := sub(I, permuteVars);
    {sigma, J}
);


-- To verify that all 5-sunlets are identifiable from each other, we just need to show that every pair of ideals is distinct
all(subsets(keys fiveSunletIdeals, 2), netPair ->  fiveSunletIdeals#(netPair_0) != fiveSunletIdeals#(netPair_1))